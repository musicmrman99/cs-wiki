# Introduction

## What are Programming and Software Engineering?

Before we begin, I will briefly consider what we mean by programming, software development, and software engineering (SE). These three things are all about creating software - applications (or 'apps'), websites, games, APIs, etc. - that run on a computer, but their precise definitions are a matter of debate.

I consider both 'programming' and 'development' to mean "writing code to tell a computer what you want it to do, and using relevant tools to convert that code into a usable application", and 'software engineering' to mean "constructing a mental model of the problem and at least one solution that achieves all intended goals, has all relevant beneficial characteristics, and allows you to communicate your solution to relevant stakeholders[note 1] in a way that they will understand." As such, 'software engineering' is a much broader term than 'programming' or 'development', and this Introduction to Software Engineering covers (sometimes briefly) many of the different areas. These definitions may have omissions or other issues, but I believe they are adequate explanations for someone just entering the field of software creation.

## What Does SE Primarily Involve?

???

- 'Computational thinking' is the process of supporting a computing device (anything from a classroom calculator to a quantum computer) to support us in reaching our goals, often requiring modelling of the problem domain and devising algorithmic (step-by-step) processes.

???

## What are the Main Challenges of SE?

Creating software can be challenging even for experienced engineers, primarily due to having to manage complexity. Management of complexity is achieved by reducing the amount of it that enters systems to only what is required, understanding and managing it once it does enter systems, and eliminating it from systems where it is no longer required. Complexity of systems comes from a range of sources:

| Challenge     | Description |
|---------------|-------------|
| Domain        | Precisely defining all of the domain concepts, their relationships, their states, and their state transitions in large, complex systems (such as organisations) |
| Compliance    | Meeting all the additional requirements that come from the software's context of use (such as hardware, OSes, libraries, APIs, legal requirements) |
| Change        | Maintaining the ability to repurpose software in a changing domain and context over time |
| Comprehension | Creating a shared understanding of software and clearly and concisely documenting (including visually representing) software |
| Velocity      | Stabalising the outcome/effort ratio over time |

## Notes

1. At this stage, it is likely that the only 'relevant stakeholder' is yourself - you're probably either making a program for you to use yourself or are just making one to learn to program without intending to use it afterwards.

## Wider Reading

- https://stevemcconnell.com/articles/software-engineering-principles/

---

- What motivates people to do software engineering?
  - mission (in 'process-based SE')
  - ownership (in 'commitment-based SE')

  - sources:
    - https://stevemcconnell.com/articles/cargo-cult-software-engineering/
